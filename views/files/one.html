<!DOCTYPE html>
<html lang="en-us">

<head>
    <meta charset="UTF-8">
    <title>浏览器介绍</title>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="stylesheet" type="text/css" href="../css/normalize.css" media="screen">
    <link rel='stylesheet' type='text/css' href='../css/fonts.css'>
    <link rel="stylesheet" type="text/css" href="../css/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../css/github-light.css" media="screen">
</head>

<body>
    <section class="main-content">
        <h1>浏览器介绍</h1>
        <h3>一、浏览器基本简介</h3>
        <p>浏览器是指可以显示网页服务器或者文件系统的HTML文件（标准通用标记语言的一个应用）内容，并让用户与这些文件交互的一种软件。标准的浏览器组件</p>
        <ul>
            <li>1、解析(Parsing) (HTML, XML, CSS, JavaScript)</li>
            <li>2、排版</li>
            <li>3、渲染</li>
            <li>4、图片解码</li>
            <li>5、图形加速</li>
            <li>6、网络访问</li>
            <li>7、硬件加速</li>
        </ul>
        <h3>二、浏览器内核</h3>
        <p>浏览器最重要或者说核心的部分是“渲染引擎”(习惯将之称为“浏览器内核”)，负责对网页语法的解释（如标准通用标记语言下的一个应用HTML、JavaScript）并渲染（显示）网页。 所以，通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因。</p>
        <p>
            Trident(IE内核)：该内核程序在1997年的IE4中首次被采用，是微软在Mosaic代码的基础之上修改而来的，并沿用到IE11，也被普遍称作”IE内核”。Trident实际上是一款开放的内核，其接口内核设计的相当成熟，因此才有许多采用IE内核而非IE的浏览器(壳浏览器)涌现。
            <br>由于IE本身的“垄断性”（虽然名义上IE并非垄断，但实际上，特别是从Windows 95年代一直到XP初期，就市场占有率来说IE的确借助Windows的东风处于“垄断”的地位）而使得Trident内核的长期一家独大，微软很长时间都并没有更新Trident内核，这导致了两个后果——一是Trident内核曾经几乎与W3C标准脱节（2005年），二是Trident内核的大量 Bug等安全性问题没有得到及时解决，然后加上一些致力于开源的开发者和一些学者们公开自己认为IE浏览器不安全的观点，也有很多用户转向了其他浏览器，Firefox和Opera就是这个时候兴起的。非Trident内核浏览器的市场占有率大幅提高也致使许多网页开发人员开始注意网页标准和非IE浏览器的浏览效果问题。
            <br> Gecko（跨平台）：Netscape6开始采用的内核，后来的Mozilla FireFox(火狐浏览器) 也采用了该内核，Gecko的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。因为这是个开源内核，因此受到许多人的青睐，Gecko内核的浏览器也很多，这也是Gecko内核虽然年轻但市场占有率能够迅速提高的重要原因。事实上，Gecko引擎的由来跟IE不无关系，前面说过IE没有使用W3C的标准，这导致了微软内部一些开发人员的不满；他们与当时已经停止更新了的 Netscape的一些员工一起创办了Mozilla，以当时的Mosaic内核为基础重新编写内核，于是开发出了Gecko。不过事实上，Gecko 内核的浏览器仍然还是Firefox (火狐)
            <br> WebKit（跨平台）:由KHTML发展而来，也是苹果给开源世界的一大贡献。是目前最火热的浏览器内核，火热倒不是说市场份额，而是应用的面积和势头。因为是脱胎于KHTML，所以也是具有高速的特点，同样遵循W3C标准。从目前看来，WebKit内核是最有潜力而且是已经有相当成绩的新兴内核，性能非常好，而且对W3C标准的支持很完善。
        </p>
        <h3>三、浏览器~加载，解析，渲染</h3>
        <p>为什么要了解浏览器加载、解析、渲染这个过程？</p>
        <ul>
            <li>1、了解浏览器如何进行加载，我们可以在引用外部样式文件，外部js时，将他们放到合适的位置，使浏览器以最快的速度将文件加载完毕。</li>
            <li>2、了解浏览器如何进行解析，我们可以在构建DOM结构，组织css选择器时，选择最优的写法，提高浏览器的解析速率。</li>
            <li>3、了解浏览器如何进行渲染，明白渲染的过程，我们在设置元素属性，编写js文件时，可以减少重绘重新布局“的消耗。</li>
        </ul>
        <p>这三个过程在实际进行的时候又不是完全独立，而是会有交叉。会造成一边加载，一边解析，一边渲染的工作现象。</p>
        <p>浏览器是如何进行加载、解析、渲染的呢？</p>
        <ul>
            <li>1、用户访问网页，DNS服务器（域名解析系统）会根据用户提供的域名查找对应的IP地址，找到后，系统会向对应IP地址的网络服务器发送一个http请求。</li>
            <li>2、网络服务器解析请求，并发送请求给数据库服务器。</li>
            <li>3、数据库服务器将请求的资源返回给网络服务器，网络服务器解析数据，并生成html文件，放入http response中，返回给浏览器。</li>
            <li>4、浏览器解析 http response。 1~4步骤需要了解HTTP协议。 访问服务器端可能遭遇的问题：如果网络服务器无法获取数据库服务器返回的资源文件（http response 404），或者由于并发原因暂时无法处理用户的http请求（http response 500） 文／Miss____Du（简书作者） 原文链接：http://www.jianshu.com/p/e141d1543143 著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。
            </li>
            <li>5、浏览器解析 http response后，需要下载html文件，以及html文件内包含的外部引用文件，及文件内涉及的图片或者多媒体文件。</li>
        </ul>
        <p>关于加载顺序：当浏览器获得一个html文件时，会”自上而下“加载，并在加载过程中进行解析渲染。</p>
        <p>加载即为获取资源文件的过程，不同浏览器，以及他们的不同版本在实现这一过程时，会有不同的实现效果(资源间互相阻塞)，。（需要学习使用timeline来做测试，我还不太会用，学会了在上文。）</p>
        <p>加载过程中遇到外部css文件，浏览器另外发出一个请求，来获取css文件。 遇到图片资源，浏览器也会另外发出一个请求，来获取图片资源。这是异步请求，并不会影响html文档进行加载，但是当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。
        </p>
        <p>原因：JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。 办法：可以将外部引用的js文件放在 &lt;/body&gt;前。
        </p>
        <p>原因：可能会有 var width = $('#id').width()，这意味着，js代码执行前，浏览器必须保证css文件已下载和解析完成。这也是css阻塞后续js的根本原因。 办法：当js文件不需要依赖css文件时，可以将js文件放在头部css的前面。
        </p>
        <p>当然除了，&lt;link href=""  /&gt;这种形式，内部&lt;style&gt;&lt;/style&gt;这种样式定义，在考虑阻塞时也要考虑。</p>
        <p>不要在外部调用的js文件中调用运行时间较长的函数，如果一定要用，可以使用setTimeout函数。</p>
    </section>
</body>

</html>
